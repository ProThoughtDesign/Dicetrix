import { DieColor } from '../../../shared/types/game.js';

/**
 * Die class representing individual dice in the game
 * Extends Phaser.GameObjects.Sprite for rendering capabilities
 */
export class Die extends Phaser.GameObjects.Sprite {
  public sides: number; // 4, 6, 8, 10, 12, 20
  public number: number; // 1 to max for sides
  public color: DieColor;
  public isWild: boolean; // matches any number
  public isBlack: boolean; // debuff die (Hard/Expert only)

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    sides: number,
    color: DieColor,
    isWild: boolean = false,
    isBlack: boolean = false
  ) {
    // Use a default texture key, will be set properly in renderNumber
    super(scene, x, y, 'die-placeholder');

    this.sides = sides;
    this.color = color;
    this.isWild = isWild;
    this.isBlack = isBlack;

    // Roll initial number
    this.roll();

    // Add to scene (only if scene has add method)
    if (scene.add && scene.add.existing) {
      scene.add.existing(this);
    }

    // Initial render
    this.renderNumber();
  }

  /**
   * Roll the die to get a random number between 1 and max sides
   */
  public roll(): void {
    if (this.isWild) {
      // Wild dice don't have a specific number, set to 0 as indicator
      this.number = 0;
    } else {
      this.number = Math.floor(Math.random() * this.sides) + 1;
    }
  }

  /**
   * Render the die with appropriate texture and number display
   */
  public renderNumber(): void {
    // Set texture based on die properties
    let textureKey = '';

    if (this.isBlack) {
      textureKey = `die-black-${this.sides}`;
    } else if (this.isWild) {
      textureKey = `die-wild-${this.color}`;
    } else {
      textureKey = `die-${this.color}-${this.sides}`;
    }

    // Set the texture (generated by DiceRenderer) - only if method exists
    if (this.setTexture) {
      this.setTexture(textureKey);
    }

    // Scale die based on grid cell size - only if method exists
    if (this.setDisplaySize) {
      this.setDisplaySize(32, 32);
    }

    // Set origin to center for proper positioning - only if method exists
    if (this.setOrigin) {
      this.setOrigin(0.5, 0.5);
    }

    // Add subtle neon glow effect
    this.addNeonGlow();
  }

  /**
   * Add neon glow effect to the die
   */
  private addNeonGlow(): void {
    // Create a subtle glow effect based on die color
    const glowColor = this.getGlowColor();

    // Set a subtle tint for the neon effect - only if method exists
    if (this.setTint) {
      this.setTint(glowColor);
    }

    // Add post-processing glow (would be handled by VisualEffectsManager in actual game)
    if (this.setAlpha) {
      this.setAlpha(0.95); // Slight transparency for glow effect
    }
  }

  /**
   * Get glow color based on die properties
   */
  private getGlowColor(): number {
    if (this.isBlack) return 0xff0000;
    if (this.isWild) return 0xffffff;

    const colorMap: Record<DieColor, number> = {
      red: 0xff3366,
      blue: 0x3366ff,
      green: 0x33ff66,
      yellow: 0xffff33,
      purple: 0xcc33ff,
      orange: 0xff9933,
      cyan: 0x33ffff,
    };

    return colorMap[this.color] || 0xffffff;
  }

  /**
   * Get the value used for matching (Wild dice return special value)
   */
  public getMatchValue(): number {
    if (this.isWild) {
      return -1; // Special value indicating wild match
    }
    return this.number;
  }

  /**
   * Check if this die can match with another die
   */
  public canMatchWith(otherDie: Die): boolean {
    // Wild dice match with anything
    if (this.isWild || otherDie.isWild) {
      return true;
    }

    // Regular dice match if they have the same number
    return this.number === otherDie.number;
  }

  /**
   * Get display text for the die (for debugging or UI)
   */
  public getDisplayText(): string {
    if (this.isBlack) {
      return 'BLACK';
    }
    if (this.isWild) {
      return 'WILD';
    }
    return this.number.toString();
  }

  /**
   * Create a copy of this die with the same properties
   */
  public clone(scene: Phaser.Scene, x?: number, y?: number): Die {
    const newDie = new Die(
      scene,
      x ?? this.x,
      y ?? this.y,
      this.sides,
      this.color,
      this.isWild,
      this.isBlack
    );

    // Copy the current number (don't re-roll)
    newDie.number = this.number;
    newDie.renderNumber();

    return newDie;
  }

  /**
   * Upgrade die to maximum values for current mode (used in Ultimate Combo)
   */
  public upgradeToMax(maxSides: number): void {
    if (!this.isWild && !this.isBlack) {
      this.sides = maxSides;
      this.number = maxSides;
      this.renderNumber();
    }
  }

  /**
   * Convert to wild die (used in size effects)
   */
  public convertToWild(): void {
    this.isWild = true;
    this.isBlack = false;
    this.number = 0;
    this.renderNumber();
  }

  /**
   * Get die data for serialization/API calls
   */
  public toData(): {
    sides: number;
    number: number;
    color: DieColor;
    isWild: boolean;
    isBlack: boolean;
  } {
    return {
      sides: this.sides,
      number: this.number,
      color: this.color,
      isWild: this.isWild,
      isBlack: this.isBlack,
    };
  }

  /**
   * Create die from data (for deserialization)
   */
  public static fromData(
    scene: Phaser.Scene,
    x: number,
    y: number,
    data: {
      sides: number;
      number: number;
      color: DieColor;
      isWild: boolean;
      isBlack: boolean;
    }
  ): Die {
    const die = new Die(scene, x, y, data.sides, data.color, data.isWild, data.isBlack);
    die.number = data.number;
    die.renderNumber();
    return die;
  }
}
